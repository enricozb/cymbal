[rust.queries]
enum     = '(enum_item name: (type_identifier) @symbol)'
struct   = '(struct_item name: (type_identifier) @symbol)'
method   = '(declaration_list (function_item name: (identifier) @symbol))'
function = '(function_item name: (identifier) @symbol)'
impl     = [
  '(impl_item !trait type: (type_identifier) @symbol)',
  { leading = ' {trait} for', query = '(impl_item trait: _ @trait (type_identifier) @symbol)' },
  # extend::ext implementations with the name as the symbol
  '(attribute (scoped_identifier) @attr (#eq? @attr "extend::ext") arguments: (_ "=" _ @symbol ")"))',
]
macro    = '(macro_definition name: (identifier) @symbol)'
module   = '(mod_item name: (identifier) @symbol)'
trait    = '(trait_item name: (type_identifier) @symbol)'
type     = '(type_item name: (type_identifier) @symbol)'

[odin.queries]
struct   = '(struct_declaration (identifier) @symbol "::")'
method   = '(procedure_declaration (identifier) @symbol)'
type     = '(const_declaration (identifier) @symbol)'
module   = '(import_declaration alias: (identifier) @symbol)'

[python.queries]
function = '(function_definition name: (identifier) @symbol)'
class = '(class_definition name: (identifier) @symbol)'

[go.queries]
# function = [
#   "entity.name.function.go"
#   "variable.other.readwrite.declaration.go - meta.block.go"
# ]
# type = "entity.name.type.go"
# const = "variable.other.constant.declaration.go - meta.block.go"

[typescript.queries]
class = '(class_declaration name: (type_identifier) @symbol)'
method = '(method_signature name: (property_identifier) @symbol)'
function = [
  '(function_declaration name: (identifier))',
  '(program (lexical_declaration (variable_declarator name: (identifier) @symbol value: (arrow_function))))',
  '(program (export_statement (lexical_declaration (variable_declarator name: (identifier) @symbol value: (arrow_function)))))',
]

[c.queries]
struct = '(struct_specifier name: (type_identifier) @symbol)'
type = [
  '(declaration type: (union_specifier name: (type_identifier) @symbol))',
  '(type_definition declarator: (type_identifier) @symbol)'
]
function = '(function_declarator declarator: (identifier) @symbol)'
enum = '(enum_specifier name: (type_identifier) @symbol)'

[cpp.queries]
type = [
  '(type_definition declarator: (type_identifier) @symbol)',
  '(enum_specifier name: (type_identifier) @symbol)',
]
class = [
  '(struct_specifier name: (type_identifier) @symbol body:(_))',
  '(declaration type: (union_specifier name: (type_identifier) @symbol))',
  '(class_specifier name: (type_identifier) @symbol)',
]
function = [
  '(function_declarator declarator: (identifier) @symbol)',
  '(function_declarator declarator: (field_identifier) @symbol)',
]
method = '(function_declarator declarator: (qualified_identifier scope: (namespace_identifier) name: (identifier) @symbol))'

[haskell.queries]
type = [
  '(type_synomym name: (name) @symbol)',
  '(data_type name: (name) @symbol)',
]
function = '(haskell declarations: (declarations (signature name: (variable) @symbol)))'
